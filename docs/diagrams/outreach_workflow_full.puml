@startuml Outreach_Workflow_Full
title Employee Outreach Workflow - Complete End-to-End Flow
autonumber

participant "CLI" as CLI
participant "FastAPI\nController" as CTRL
participant "OutreachService" as SVC
participant "EmployeeOutreach\nAgent" as AGENT
participant "LinkedInMCP\nClientSync" as MCP_CLIENT
participant "LinkedIn MCP\nServer" as MCP_SERVER
participant "Browser\nGraphs" as GRAPHS
participant "AgentDB" as DB
participant "SharedDB\n(SearchResult)" as SHARED_DB
participant "SessionStore" as SESS
participant "Kafka" as KAFKA

== PHASE 1: SEARCH & CLUSTER (Async via Kafka) ==

CLI -> CTRL: POST /api/outreach/search\n{filters, credentials, total_limit,\ncompany_limit, segment}
activate CTRL

CTRL -> SVC: submit_search(request)
activate SVC

SVC -> SVC: Generate task_id
SVC -> SVC: Spawn thread: _run_search()
SVC --> CTRL: task_id
deactivate SVC

CTRL --> CLI: {task_id}
deactivate CTRL

CLI -> KAFKA: consume(outreach-search-results,\ntask_id, timeout=3600s)
activate CLI #LightGreen
note over CLI: CLI polls Kafka\nfor search results

activate SVC #LightBlue
note over SVC: Background Thread

SVC -> DB: CompanyDB.filter_companies(filters)
DB --> SVC: [company dicts]

SVC -> SVC: Apply company_limit slice

SVC -> AGENT: run_search_only(companies, credentials)
activate AGENT

AGENT -> DB: get_messaged_profile_urls()
DB --> AGENT: {messaged URLs}

AGENT -> AGENT: Generate batch_id

AGENT -> MCP_CLIENT: search_employees_batch(\ncompanies, batch_id, exclude_profile_urls)
activate MCP_CLIENT

MCP_CLIENT -> MCP_SERVER: HTTP POST /mcp\ncall_tool("search_employees_batch")
activate MCP_SERVER

MCP_SERVER -> MCP_SERVER: submit_search_batch()\nSpawn background thread
MCP_SERVER --> MCP_CLIENT: {"batch_id": "uuid"}
deactivate MCP_SERVER

MCP_CLIENT --> AGENT: {"batch_id": "uuid"}
deactivate MCP_CLIENT

note over AGENT: Agent now waits\nfor Kafka completion

activate MCP_SERVER #LightCoral
note over MCP_SERVER: Background Thread

MCP_SERVER -> MCP_SERVER: _ensure_authenticated()
MCP_SERVER -> GRAPHS: LinkedInAuthGraph.execute()
GRAPHS --> MCP_SERVER: authenticated

loop For each company
    MCP_SERVER -> GRAPHS: EmployeeSearchGraph.execute()
    GRAPHS --> MCP_SERVER: [employees]
    MCP_SERVER -> MCP_SERVER: Filter exclude_profile_urls
    MCP_SERVER -> SHARED_DB: INSERT SearchResult rows\n(batch_id, company, employees)
end

MCP_SERVER -> MCP_SERVER: close_browser()
MCP_SERVER -> KAFKA: publish(mcp-search-complete,\nbatch_id, MCPSearchComplete)
deactivate MCP_SERVER

AGENT -> KAFKA: consume(mcp-search-complete,\nbatch_id, timeout=3600s)
KAFKA --> AGENT: MCPSearchComplete\n{status, total_employees, companies_processed}

AGENT -> SHARED_DB: get_search_results(batch_id)
SHARED_DB --> AGENT: [employee dicts]

AGENT -> SHARED_DB: delete_search_results(batch_id)

AGENT -> AGENT: Flatten results, add company_name
AGENT --> SVC: employees_found
deactivate AGENT

SVC -> DB: Filter already-messaged (safety net)
SVC -> SVC: cluster_employees_by_role(employees)

alt Segment filter requested
    SVC -> SVC: filter_by_segment(clustered, segment)
    SVC -> SVC: Apply total_limit after filtering
end

SVC -> SESS: create(employees, clustered, companies)
SESS -> DB: save_session(session_id, data, ttl=3600)
SESS --> SVC: session_id

SVC -> KAFKA: publish(outreach-search-results,\ntask_id, OutreachSearchResponse)
deactivate SVC

KAFKA --> CLI: OutreachSearchResponse\n{session_id, role_groups, total_employees}
deactivate CLI

CLI -> CLI: Display role_groups\nUser selects roles & templates

== PHASE 2: SEND MESSAGES (Async via Kafka) ==

CLI -> CTRL: POST /api/outreach/send\n{session_id, selected_groups, credentials}
activate CTRL

CTRL -> SVC: submit_send(request)
activate SVC

SVC -> SESS: get(session_id)
SESS -> DB: get_session(session_id)
SESS --> SVC: session data

SVC -> SVC: Generate task_id
SVC -> SVC: Spawn thread: _run_send()
SVC -> SESS: delete(session_id)

SVC --> CTRL: task_id
deactivate CTRL

CTRL --> CLI: {task_id}

activate SVC #LightBlue
note over SVC: Background Thread

SVC -> SVC: Build employees_with_templates\n(attach _template, _role)

SVC -> AGENT: run_send(employees_with_templates,\ncredentials, daily_limit)
activate AGENT

loop For each employee
    AGENT -> DB: was_already_messaged(url)?
    DB --> AGENT: bool

    alt Not already messaged
        AGENT -> AGENT: render_template(template, vars)

        AGENT -> MCP_CLIENT: send_message(url, name, message)
        activate MCP_CLIENT

        MCP_CLIENT -> MCP_SERVER: call_tool("send_message")
        activate MCP_SERVER

        MCP_SERVER -> GRAPHS: MessageSendGraph.execute()
        activate GRAPHS
        GRAPHS -> GRAPHS: navigate_to_profile
        GRAPHS -> GRAPHS: detect_action (Message/Connect)
        alt Message button available
            GRAPHS -> GRAPHS: send_direct_message()
        else Connect only
            GRAPHS -> GRAPHS: send_connection_request()
        end
        GRAPHS --> MCP_SERVER: MessageResult
        deactivate GRAPHS

        MCP_SERVER --> MCP_CLIENT: {sent, method, error}
        deactivate MCP_SERVER

        MCP_CLIENT --> AGENT: result
        deactivate MCP_CLIENT

        AGENT -> DB: record_message(url, success, method)

        alt sent == true
            AGENT -> DB: increment_daily_quota()
        end
    end

    alt messages_sent >= daily_limit
        AGENT -> AGENT: Break loop
    end
end

AGENT --> SVC: {message_results, messages_sent_today}
deactivate AGENT

SVC -> SVC: Build results_by_role
SVC -> KAFKA: publish(outreach-results,\ntask_id, OutreachSendResponse)

deactivate SVC

par CLI Kafka Consumer
    CLI -> KAFKA: consume(outreach-results,\ntask_id, timeout=600s)
    activate KAFKA

    loop Poll for task_id
        KAFKA -> KAFKA: Check message key == task_id
    end

    KAFKA --> CLI: OutreachSendResponse
    deactivate KAFKA

    CLI -> CLI: Display results_by_role\nPrint summary
end

@enduml
